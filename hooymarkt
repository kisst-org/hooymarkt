#!/usr/bin/env bash
# Script Name: render-manifests
# Description: render helm manifests for applications and environments
# Author: Mark Hooijkaas
# Sourcecode: https://github.com/kisst-org/markisst/
# License: Apache License version 2.0
# Install or update to newest version with following command:
#   curl -OL https://raw.githubusercontent.com/kisst-org/markisst/refs/heads/main/render-manifests && chmod 755 render-manifests

set -eu
shopt -s extglob
script_name="${0}"

read_config() {
    : ${RENDER_CONFIG_FILE:=${RENDER_ROOT_DIR:-.}/render.config}
    main_command=forall_apps_envs
    if [[ -f ${RENDER_CONFIG_FILE} ]]; then
        source ${RENDER_CONFIG_FILE}
    fi
    default_renderer=${RENDER_DEFAULT_RENDERER:-helm}
}


main() {
    declare -A enabled=( [render]=true [forall-appenvs]=true)
    local command_list=git-pull,forall-appenvs,commit-all
    local action_list=update,render,diff,add,commit-each
    declare -A aliases
    declare -A kubectl_options
    declare -A action_funcs
    read_config
    parse_options "${@}"
    run_commands
}

verbose() { if ${log_verbose:-false}; then printf "%s " "${@}"; echo; fi }
info()    { if ${log_info:-true};     then echo "${@}"; fi }
verbose_cmd() {
    if ${log_verbose:-false}; then printf "    "; echo "${@}"; fi
    cmd=$1; shift
    $cmd "${@}"
}
get_lhs() { echo ${1/=*([^=])/}; }  # get the lhs (left hand side) from lhs=rhs
get_rhs() { echo ${1/*([^=])=/}; }  # get the rhs (right hand side) from lhs=rhs

replace_aliases() {
    declare -ag parsed_args=()
    for arg in "${@}"; do
        lhs=$(get_lhs $arg)
        local al=${aliases[$lhs]:-none}
        if [[ $al != none ]]; then
            rhs=$(get_rhs $arg)
            if [[ -z $rhs ]]; then
                parsed_args+=("$arg")
            else
                parsed_args+=($(printf "%s" "$al"))
            fi
        else
            parsed_args+=("$arg")
        fi

    done
}

parse_options() {
    replace_aliases "$@"
    def_files=""
    envs=""
    actions=render
    declare -ag updates=()
    for arg in "${parsed_args[@]}"; do
        case $arg in
            -h|--help|help) main_command=show_help;;
            -v|--verbose)   log_verbose=true; log_info=true;;
            -q|--quiet)     log_verbose=false; log_info=false;;
            --debug)        set -x;;
            --env=*)        envs+=" $(get_rhs $arg)";;
            --envs=*)       envs="$(get_rhs $arg)";;
            --action=*)     action_list+=("$(get_rhs $arg)");;
            --actions=*)    action_list=("$(get_rhs $arg)");;
            update:*)       updates+=(${arg#update:}) ;;
            diff)           actions+=" diff";;
            apply)          actions+=" apply";;
            compare)        actions="compare";; # will render
            *)
                if [[ -f ${arg} ]]; then def_files+=" ${arg}"
                elif [[ -d ${arg} ]]; then def_files+=" ${arg}/*.def"
                else
                    echo unknown argument ${arg}, should be a command, file or directory with \*.def file
                    show_help
                    exit 1
                fi
        esac
        shift
    done
    verbose running $(basename $0) ${parsed_args[@]}
    if [[ -z $envs ]]; then envs=${RENDER_DEFAULT_ENVS:-tst}; fi
    envs=${envs//,/ }  # split on comma
    # better test that also works with one or more spaces, might be:
    #   if [[ ${envs:-} =~ '^ *$' ]]; then ...
    # see https://unix.stackexchange.com/questions/146942/how-can-i-test-if-a-variable-is-empty-or-contains-only-spaces
}


show_help() { cat <<EOF
$(basename ${script_name}) [ option | command/alias | render-def ]...

Options:
  -h|--help     show this help
  -v|--verbose  give more output
  -q|--quiet    no output
  -e|--env=<e>  add environment <e> to render
Commands
  help          show_help
  diff          run 'kubectl diff' with the rendered manifests
  apply         run 'kubectl apply' with the rendered manifests
  compare       compare to same appname in other directory
  update:<expr> for helm update the final values with yq expression
  commit        TODO: run 'git commit' (pull is implied)
  pull          TODO: run 'git pull' before starting to render, to avoid merge conflicts

Render Definitions:
Can either be a file, that will be sourced, or a directory that contains exactly 1 file with a name 'render*.def'.

Aliases:
EOF
for key in $(printf "%s\n" ${!aliases[@]} | sort); do
    printf "  %-13s %s\n" $key "${aliases[$key]}"
done
}

################################################
# generic functions

run_commands() {
    for command in ${command_list//,/ }; do
        if ${enabled[$command]:-false}; then
            verbose running command $command
            run_command_$command;
        else
            verbose skipping command $command
        fi
    done
}

run_command_git-pull() { git pull; }
run_command_forall-appenvs() {
    if ${order_appens:-true}; then
        for def_file in $def_files; do
            for env in $envs; do
                run_actions
            done
        done
    else
        for env in $envs; do
            for f in $def_files; do
                run_actions
            done
        done
    fi
}


run_actions() {
    verbose reading def ${def_file} for ${env}
    renderer=${default_renderer}
    source ${def_file}
    init_$renderer
    if [[ ! -f ${main_env_file} ]]; then
        info skipping $appname $env
        return 0
    fi
    for action in ${action_list//,/ }; do
        if ${enabled[$action]:-false}; then
            info running $action for ${env} ${appname} to ${output_dir}
            run_action_$action;
        fi
    done
}

run_action_update() {
    update_last_helm_values_file
}

run_action_render() {
    render_helm
}

run_action_diff() {
    info diffing $output_dir
    verbose_cmd kubectl diff ${kubectl_options[$env]} -f $output_dir || true
}

run_action_apply() {
    info applying $output_dir
    verbose_cmd kubectl apply ${kubectl_options[$env]} -f $output_dir
}


calc_origfile() { echo ${compare_dir}/$def_file; }
run_action_compare() {
    run_actions $def_file render
    newdir=$output_dir
    orig_file=$(calc_origfile)
    run_actions ${orig_file} render
    olddir=$output_dir
    info diffing $newdir $olddir
    pre_diff_cleanup $newdir $olddir
    verbose_cmd diff -r $newdir $olddir || true
}

basic_cleanup () {
    verbose removing comments, rollme,
    sed -i -e '/^ *#/d' -e '/rollme/d' $1/*.yaml $2/*.yaml
    verbose fixing unneeded quotes
    sed -i -e 's/: "\([a-zA-Z].*\)"$/: \1/' $1/*.yaml $2/*.yaml
    sed -i -e 's/: "\([a-zA-Z0-9].*[a-zA-Z]\)"$/: \1/' $1/*.yaml $2/*.yaml
}

pre_diff_cleanup() {
    basic_cleanup $1 $2
}

split_into_files() {
    yq -s \"$output_dir/\"'+ (.kind | downcase) + "_" + .metadata.name + ".yaml"'
    rm -f ${output_dir}/_.yaml
}

################################################
# helm module

update_last_helm_values_file() {
    local f=${helm_value_files[-1]}
    for u in ${updates[@]}; do
        verbose_cmd yq -i $u $f
    done
}

init_helm_dirs() {
    base_dir=$1
    env_dir=${base_dir}/envs
    manifest_dir=${base_dir}/manifests
    output_dir=${manifest_dir}/${env}/${appname}
    helm_chart_dir=${base_dir}/helm-charts
}

init_helm() {
    def_file_dir=$(dirname ${def_file})
    init_helm_dirs $(dirname $(dirname $def_file_dir))
    : ${helm_charts:=${charts:-}}
    main_env_file="$def_file_dir/values-${appname}-${env}.yaml"
    helm_release=$appname # this is probably not really used with helm template
    helm_command="helm template"
    helm_value_files=(${env_dir}/values-env-${env}.yaml)
    helm_value_files+=($def_file_dir/values-app-${appname}.yaml)
    helm_value_files+=($main_env_file)
    run_update_func=update_last_helm_values_file
}

render_helm() {
    local f
    for f in ${helm_value_files}; do helm_command+=" -f ${f}"; done
    helm_command+=" $helm_release"
    for ch in $helm_charts; do
        local cmd="$helm_command $helm_chart_dir/$ch"
        verbose "    $cmd"
        $cmd | split_into_files
    done
}



main "${@}"
