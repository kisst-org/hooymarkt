#!/usr/bin/env bash
# Script Name: render-manifests
# Description: render helm manifests for applications and environments
# Author: Mark Hooijkaas
# Sourcecode: https://github.com/kisst-org/markisst/
# License: Apache License version 2.0
# Install or update to newest version with following command:
#   curl -OL https://raw.githubusercontent.com/kisst-org/markisst/refs/heads/main/render-manifests && chmod 755 render-manifests

set -eu

declare -A env_names
env_names[t]=tst
env_names[tst]=tst
env_names[stg]=stg
env_names[prd]=prd
env_names[all]=all


: ${RENDER_ROOT_DIR:=$(dirname $(readlink -f ${BASH_SOURCE[0]}))}
: ${RENDER_ENV_DIR:=${RENDER_ROOT_DIR}/envs}
: ${RENDER_CHART_DIR:=${RENDER_ROOT_DIR}/helm-charts}
: ${RENDER_OUTPUT_DIR:=${RENDER_ROOT_DIR}/manifests}
: ${RENDER_CONFIG_FILE:=${RENDER_ROOT_DIR}/render.config}
: ${RENDER_ALL_ENVS:="tst stg prd"}

if [[ -f ${RENDER_CONFIG_FILE} ]]; then
    source ${RENDER_CONFIG_FILE}
fi

main() {
    parse_options "${@}"
    for file in $def_files; do
        verbose reading render-def ${file} for ${envs}
        . $file
        if [[ $envs == *all* ]]; then
            # all_envs might be different for each application
            envs=${all_envs:-${RENDER_ALL_ENVS}}
        fi
        for env in $envs; do
            info rendering ${appname}-${env}
            dir=manifests/${env}/${appname}
            rm -rf $dir; mkdir -p $dir
            render
        done
    done
}


verbose() { if ${log_verbose:-false}; then printf "%s " "${@}"; echo; fi }
info()    { if ${log_info:-true};     then echo "${@}"; fi }
run_verbose() { cmd=$1; shift; verbose "    $cmd" "${@}"; $cmd "${@}"; }

# The following function is
render() { render_helm; }

parse_options() {
    def_files=""
    envs=""
    while [ ! $# -eq 0 ]; do
        case $1 in
            -h|--help)     show_help; exit 0;;
            -v|--verbose)  log_verbose=true; log_info=true;;
            -q|--quiet)    log_verbose=false; log_info=false;;
            --debug)       set -x;;
            @*)            e=${env_names[${1#@}]}; envs+=" $e" ;;
            *)
                if [[ ! -z ${env_names[$1]:-} ]]; then envs+=" ${env_names[$1]}"
                elif [[ -f $1 ]]; then def_files+=" $1"
                elif [[ -d $1 ]]; then def_files+=" $1/render-app-*.def"
                fi
        esac
        shift
    done
    if [[ -z $envs ]]; then envs=${RENDER_DEFAULT_ENVS:-tst}; fi
    # better test that also works with one or more spaces, might be:
    #   if [[ ${envs:-} =~ '^ *$' ]]; then ...
    # see https://unix.stackexchange.com/questions/146942/how-can-i-test-if-a-variable-is-empty-or-contains-only-spaces

}


show_help() { cat <<EOF
render-manifests [options] [environment...] <render-def>...

Options:
  -h|--help        show this help
  -v|--verbose     give more output
  -q|--quiet       no output
  -d|--diff        run 'kubectl diff' with the rendered manifests
  -a|--apply       run 'kubectl apply' with the rendered manifests
  -c|--commit      run 'git commit' (--pull is implied)
  -p|--pull        run 'git pull' before starting to render, to avoid merge conflicts
  -o|--output-dir  the directory where manifests will be rendered to

Environments:
It is possible to specify an environment as follows '@lab'.
Shortcuts e.g. '@l' and even just 'l' or 'lab' are planned

Render Definitions:
Can either be a file, that will be sourced, or a directory that contains exactly 1 file with a name 'render-*.def'.
EOF
}


split_into_files() {
    yq -s \"$dir/\"'+ (.kind | downcase) + "_" + .metadata.name + ".yaml"'
}

if_file_exists() { if [[ -f $1 ]]; then echo " ${2:-} $1"; else echo "" ; fi }
render_helm() {
    release=$appname-$env # this is probably not really used with helm template
    defdir=$(dirname $(readlink -f ${file}))

    value_opts=""
    value_opts+=$(if_file_exists $RENDER_ENV_DIR/values-env-${env}.yaml -f)
    value_opts+=$(if_file_exists $defdir/values-app-${appname}.yaml -f)
    value_opts+=$(if_file_exists $defdir/values-appenv-${appname}-${env}.yaml -f)
    value_opts+=$(if_file_exists $defdir/values-${appname}-${env}.yaml -f)
    for ch in $charts; do
        cmd="helm template $value_opts $release ${RENDER_CHART_DIR}/$ch"
        verbose "    $cmd"
        $cmd | split_into_files
    done
}

main "${@}"
