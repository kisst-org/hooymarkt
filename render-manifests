#!/usr/bin/env bash
# Script Name: render-manifests
# Description: render helm manifests for applications and environments
# Author: Mark Hooijkaas
# Sourcecode: https://github.com/kisst-org/markisst/
# License: Apache License version 2.0
# Install or update to newest version with following command:
#   curl -OL https://raw.githubusercontent.com/kisst-org/markisst/refs/heads/main/render-manifests && chmod 755 render-manifests

set -eu


read_config() {
    declare -A -g env_names
    env_names[t]=tst
    env_names[tst]=tst
    env_names[stg]=stg
    env_names[prd]=prd
    env_names[all]=all
    all_envs="tst stg prd"
    command=render_files
    if [[ -f ${RENDER_CONFIG_FILE} ]]; then
        source ${RENDER_CONFIG_FILE}
    fi
}


main() {
    : ${RENDER_CONFIG_FILE:=${RENDER_ROOT_DIR:-.}/render.config}
    read_config
    parse_options "${@}"
    # init_vars
    $command
}

verbose() { if ${log_verbose:-false}; then printf "%s " "${@}"; echo; fi }
info()    { if ${log_info:-true};     then echo "${@}"; fi }

parse_options() {
    def_files=""
    envs=""
    while [ ! $# -eq 0 ]; do
        case $1 in
            -h|--help)     show_help; exit 0;;
            -v|--verbose)  log_verbose=true; log_info=true;;
            -q|--quiet)    log_verbose=false; log_info=false;;
            -c|--charts)   force_charts=$2; shift ;;
            --debug)       set -x;;
            @*)            e=${env_names[${1#@}]}; envs+=" $e" ;;
            -e|--env)      envs+=" $2"; shift ;;
            d|diff)        extra_cmd=diff ;;
            apply)         extra_cmd=apply ;;
            comp|compare)  command=compare;;
            *)
                if [[ ! -z ${env_names[$1]:-} ]]; then envs+=" ${env_names[$1]}"
                elif [[ -f $1 ]]; then def_files+=" $1"
                elif [[ -d $1 ]]; then def_files+=" $1/render-app-*.def"
                fi
        esac
        shift
    done
    if [[ -z $envs ]]; then envs=${RENDER_DEFAULT_ENVS:-tst}; fi
    # better test that also works with one or more spaces, might be:
    #   if [[ ${envs:-} =~ '^ *$' ]]; then ...
    # see https://unix.stackexchange.com/questions/146942/how-can-i-test-if-a-variable-is-empty-or-contains-only-spaces

}


show_help() { cat <<EOF
render-manifests [options] [environment...] <render-def>...

Options:
  -h|--help        show this help
  -v|--verbose     give more output
  -q|--quiet       no output
  -d|--diff        run 'kubectl diff' with the rendered manifests
  -a|--apply       run 'kubectl apply' with the rendered manifests
  -c|--commit      run 'git commit' (--pull is implied)
  -p|--pull        run 'git pull' before starting to render, to avoid merge conflicts
  -o|--output-dir  the directory where manifests will be rendered to

Environments:
It is possible to specify an environment as follows '@lab'.
Shortcuts e.g. '@l' and even just 'l' or 'lab' are planned

Render Definitions:
Can either be a file, that will be sourced, or a directory that contains exactly 1 file with a name 'render-*.def'.
EOF
}

render_files() {
    for f in $def_files; do
        verbose reading render-def ${f} for ${envs}
        for env in $envs; do
            render_env $f
        done
    done
}


basic_cleanup () {
    verbose removing comments, rollme,
    sed -i -e '/^ *#/d' -e '/rollme/d' $1/*.yaml $2/*.yaml
    verbose fixing unneeded quotes
    sed -i -e 's/: "\([a-zA-Z].*\)"$/: \1/' $1/*.yaml $2/*.yaml
}

pre_diff_cleanup() {
    basic_cleanup $1 $2
}

compare() {
    for f in $def_files; do
        verbose comparing render-def ${f} for ${envs}
        for env in $envs; do
            render_env $f .
            render_env test/$f test
            newdir=manifests/$env/$appname
            olddir=test/manifests/$env/$appname
            echo diffing $newdir $olddir
            pre_diff_cleanup $newdir $olddir
            diff -r $newdir $olddir
        done
    done
}


init_app_def() {
    # read the def file to determine all_envs and helm_charts
    unset helm_charts helm_chart_for all_envs
    declare -A helm_charts_for
    source ${file}
    if [[ $envs == *all* ]]; then
        # all_envs might be different for each application
        envs=${all_envs:-${RENDER_ALL_ENVS}}
    fi
}

init_vars() {
    #: ${RENDER_ROOT_DIR:=$(dirname $(readlink -f ${BASH_SOURCE[0]}))}
    root_dir=$1
    env_dir=${root_dir}/envs
    chart_dir=${root_dir}/helm-charts
    output_dir=${root_dir}/manifests
    init_app_def
}

render_env() {
    file=$1
    init_vars ${2:-.}
    source ${env_dir}/render-env-${env}.def
    render_charts=${force_charts:-${helm_charts:-${charts}}}
    defdir=$(dirname $(readlink -f ${file}))
    if [[ -f $defdir/values-${appname}-${env}.yaml ]]; then
        info rendering ${appname}-${env} with charts ${render_charts} to $output_dir
        dir=$output_dir/${env}/${appname}
        rm -rf $dir; mkdir -p $dir
        render_helm
    else
        info skipping ${appname}-${env}
    fi
}

if_file_exists() { if [[ -f $1 ]]; then echo " ${2:-} $1"; else echo "" ; fi }
render_helm() {
    release=$appname-$env # this is probably not really used with helm template
    defdir=$(dirname ${file})
    value_opts="-f ${env_dir}/values-env-${env}.yaml"
    value_opts+=" -f $defdir/values-app-${appname}.yaml"
    value_opts+=" -f $defdir/values-${appname}-${env}.yaml"
    for ch in $render_charts; do
        cmd="helm template $value_opts $release ${chart_dir}/$ch"
        verbose "    $cmd"
        $cmd | split_into_files
    done
    if [[ ${extra_cmd:-} == diff ]]; then
        info diffing $dir
        kubectl diff --context $context -f $dir
    elif [[ ${extra_cmd:-} == apply ]]; then
        info applying $dir
        kubectl apply --context $context -f $dir
    fi
}

split_into_files() {
    yq -s \"$dir/\"'+ (.kind | downcase) + "_" + .metadata.name + ".yaml"'
    rm -f ${dir}/_.yaml
}


main "${@}"
